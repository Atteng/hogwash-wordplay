{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\n\n/**\r\n * Custom hook for game state management\r\n */\nexport function useGameState(socket, sessionId, mode) {\n  _s();\n  const [gameState, setGameState] = useState({\n    grid: [],\n    crosswordData: null,\n    completedWords: [],\n    currentScore: 0,\n    hintsUsed: 0,\n    wordHints: {},\n    // Track hints per word\n    elapsedTime: 0,\n    timerDuration: 0,\n    status: 'waiting' // waiting, active, completed\n  });\n  const [leaderboard, setLeaderboard] = useState([]);\n  const [players, setPlayers] = useState([]);\n  const [hintsRemaining, setHintsRemaining] = useState(20); // For co-op mode\n\n  /**\r\n   * Initialize game state when game starts\r\n   */\n  const initializeGame = useCallback(data => {\n    const {\n      crosswordData,\n      timerDuration\n    } = data;\n\n    // Create empty grid\n    const emptyGrid = Array(crosswordData.dimensions.rows).fill(null).map(() => Array(crosswordData.dimensions.cols).fill(''));\n    setGameState({\n      grid: emptyGrid,\n      crosswordData,\n      completedWords: [],\n      currentScore: 0,\n      hintsUsed: 0,\n      wordHints: {},\n      elapsedTime: 0,\n      timerDuration,\n      status: 'active'\n    });\n  }, []);\n\n  /**\r\n   * Update a cell in the grid\r\n   */\n  const updateCell = useCallback((row, col, value) => {\n    setGameState(prev => {\n      const newGrid = prev.grid.map(r => [...r]);\n      newGrid[row][col] = value.toUpperCase();\n      return {\n        ...prev,\n        grid: newGrid\n      };\n    });\n\n    // Emit to server\n    if (socket) {\n      socket.emit('cell-update', {\n        sessionId,\n        row,\n        col,\n        value\n      });\n    }\n  }, [socket, sessionId]);\n\n  /**\r\n   * Request a hint\r\n   */\n  const requestHint = useCallback((wordIndex, callback) => {\n    if (socket) {\n      socket.emit('request-hint', {\n        sessionId,\n        wordIndex\n      }, response => {\n        if (response.success) {\n          const {\n            hint,\n            hintsUsedOnWord,\n            totalHintsUsed,\n            hintsRemaining: remaining\n          } = response;\n\n          // Update grid with hint\n          setGameState(prev => {\n            const newGrid = prev.grid.map(r => [...r]);\n            newGrid[hint.row][hint.col] = hint.letter;\n            const newWordHints = {\n              ...prev.wordHints\n            };\n            newWordHints[wordIndex] = hintsUsedOnWord || 0;\n            return {\n              ...prev,\n              grid: newGrid,\n              hintsUsed: totalHintsUsed || prev.hintsUsed + 1,\n              wordHints: newWordHints\n            };\n          });\n          if (mode === 'coop' && remaining !== undefined) {\n            setHintsRemaining(remaining);\n          }\n        }\n        if (callback) callback(response);\n      });\n    }\n  }, [socket, sessionId, mode]);\n\n  /**\r\n   * Check if a word is complete\r\n   */\n  const checkWordComplete = useCallback(wordIndex => {\n    if (!gameState.crosswordData) return false;\n    const word = gameState.crosswordData.words[wordIndex];\n    const {\n      row,\n      col,\n      direction,\n      word: answer\n    } = word;\n    for (let i = 0; i < answer.length; i++) {\n      const r = direction === 'across' ? row : row + i;\n      const c = direction === 'across' ? col + i : col;\n      if (gameState.grid[r][c] !== answer[i]) {\n        return false;\n      }\n    }\n    return true;\n  }, [gameState.grid, gameState.crosswordData]);\n\n  /**\r\n   * Mark word as complete\r\n   */\n  const completeWord = useCallback(wordIndex => {\n    if (!gameState.crosswordData) return;\n    const word = gameState.crosswordData.words[wordIndex];\n    const hintsUsed = gameState.wordHints[wordIndex] || 0;\n    setGameState(prev => ({\n      ...prev,\n      completedWords: [...prev.completedWords, {\n        ...word,\n        hintsUsed\n      }]\n    }));\n\n    // Notify server\n    if (socket) {\n      socket.emit('word-complete', {\n        sessionId,\n        wordIndex,\n        elapsedTime: gameState.elapsedTime\n      });\n    }\n  }, [socket, sessionId, gameState.crosswordData, gameState.wordHints, gameState.elapsedTime]);\n\n  /**\r\n   * Update elapsed time\r\n   */\n  const updateElapsedTime = useCallback(time => {\n    setGameState(prev => ({\n      ...prev,\n      elapsedTime: time\n    }));\n  }, []);\n\n  /**\r\n   * Complete game\r\n   */\n  const completeGame = useCallback(callback => {\n    setGameState(prev => ({\n      ...prev,\n      status: 'completed'\n    }));\n    if (socket) {\n      socket.emit('game-complete', {\n        sessionId,\n        completionTime: gameState.elapsedTime\n      }, callback);\n    }\n  }, [socket, sessionId, gameState.elapsedTime]);\n\n  // Socket event listeners\n  useEffect(() => {\n    if (!socket) return;\n\n    // Cell updated (co-op mode)\n    socket.on('cell-updated', data => {\n      if (mode === 'coop') {\n        setGameState(prev => {\n          const newGrid = prev.grid.map(r => [...r]);\n          newGrid[data.row][data.col] = data.value;\n          return {\n            ...prev,\n            grid: newGrid\n          };\n        });\n      }\n    });\n\n    // Hint used (co-op mode)\n    socket.on('hint-used', data => {\n      if (mode === 'coop') {\n        setGameState(prev => {\n          const newGrid = prev.grid.map(r => [...r]);\n          newGrid[data.hint.row][data.hint.col] = data.hint.letter;\n          return {\n            ...prev,\n            grid: newGrid\n          };\n        });\n        setHintsRemaining(data.hintsRemaining);\n      }\n    });\n\n    // Leaderboard update (competitive mode)\n    socket.on('leaderboard-update', data => {\n      if (mode === 'competitive') {\n        setLeaderboard(data.leaderboard);\n      }\n    });\n\n    // Player joined\n    socket.on('player-joined', data => {\n      setPlayers(prev => [...prev, data]);\n    });\n\n    // Player left\n    socket.on('player-left', data => {\n      setPlayers(prev => prev.filter(p => p.playerId !== data.playerId));\n    });\n    return () => {\n      socket.off('cell-updated');\n      socket.off('hint-used');\n      socket.off('leaderboard-update');\n      socket.off('player-joined');\n      socket.off('player-left');\n    };\n  }, [socket, mode]);\n  return {\n    gameState,\n    setGameState,\n    leaderboard,\n    players,\n    setPlayers,\n    hintsRemaining,\n    initializeGame,\n    updateCell,\n    requestHint,\n    checkWordComplete,\n    completeWord,\n    updateElapsedTime,\n    completeGame\n  };\n}\n_s(useGameState, \"F0FnoWR4Btu41qSeoORAvfC2zps=\");","map":{"version":3,"names":["useState","useEffect","useCallback","useGameState","socket","sessionId","mode","_s","gameState","setGameState","grid","crosswordData","completedWords","currentScore","hintsUsed","wordHints","elapsedTime","timerDuration","status","leaderboard","setLeaderboard","players","setPlayers","hintsRemaining","setHintsRemaining","initializeGame","data","emptyGrid","Array","dimensions","rows","fill","map","cols","updateCell","row","col","value","prev","newGrid","r","toUpperCase","emit","requestHint","wordIndex","callback","response","success","hint","hintsUsedOnWord","totalHintsUsed","remaining","letter","newWordHints","undefined","checkWordComplete","word","words","direction","answer","i","length","c","completeWord","updateElapsedTime","time","completeGame","completionTime","on","filter","p","playerId","off"],"sources":["C:/Users/Awaji-Iyaham Atteng/Desktop/multiplayer-crossword/client/src/hooks/useGameState.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\n\r\n/**\r\n * Custom hook for game state management\r\n */\r\nexport function useGameState(socket, sessionId, mode) {\r\n    const [gameState, setGameState] = useState({\r\n        grid: [],\r\n        crosswordData: null,\r\n        completedWords: [],\r\n        currentScore: 0,\r\n        hintsUsed: 0,\r\n        wordHints: {}, // Track hints per word\r\n        elapsedTime: 0,\r\n        timerDuration: 0,\r\n        status: 'waiting', // waiting, active, completed\r\n    });\r\n\r\n    const [leaderboard, setLeaderboard] = useState([]);\r\n    const [players, setPlayers] = useState([]);\r\n    const [hintsRemaining, setHintsRemaining] = useState(20); // For co-op mode\r\n\r\n    /**\r\n     * Initialize game state when game starts\r\n     */\r\n    const initializeGame = useCallback((data) => {\r\n        const { crosswordData, timerDuration } = data;\r\n\r\n        // Create empty grid\r\n        const emptyGrid = Array(crosswordData.dimensions.rows)\r\n            .fill(null)\r\n            .map(() => Array(crosswordData.dimensions.cols).fill(''));\r\n\r\n        setGameState({\r\n            grid: emptyGrid,\r\n            crosswordData,\r\n            completedWords: [],\r\n            currentScore: 0,\r\n            hintsUsed: 0,\r\n            wordHints: {},\r\n            elapsedTime: 0,\r\n            timerDuration,\r\n            status: 'active',\r\n        });\r\n    }, []);\r\n\r\n    /**\r\n     * Update a cell in the grid\r\n     */\r\n    const updateCell = useCallback((row, col, value) => {\r\n        setGameState((prev) => {\r\n            const newGrid = prev.grid.map((r) => [...r]);\r\n            newGrid[row][col] = value.toUpperCase();\r\n            return { ...prev, grid: newGrid };\r\n        });\r\n\r\n        // Emit to server\r\n        if (socket) {\r\n            socket.emit('cell-update', { sessionId, row, col, value });\r\n        }\r\n    }, [socket, sessionId]);\r\n\r\n    /**\r\n     * Request a hint\r\n     */\r\n    const requestHint = useCallback((wordIndex, callback) => {\r\n        if (socket) {\r\n            socket.emit('request-hint', { sessionId, wordIndex }, (response) => {\r\n                if (response.success) {\r\n                    const { hint, hintsUsedOnWord, totalHintsUsed, hintsRemaining: remaining } = response;\r\n\r\n                    // Update grid with hint\r\n                    setGameState((prev) => {\r\n                        const newGrid = prev.grid.map((r) => [...r]);\r\n                        newGrid[hint.row][hint.col] = hint.letter;\r\n\r\n                        const newWordHints = { ...prev.wordHints };\r\n                        newWordHints[wordIndex] = hintsUsedOnWord || 0;\r\n\r\n                        return {\r\n                            ...prev,\r\n                            grid: newGrid,\r\n                            hintsUsed: totalHintsUsed || prev.hintsUsed + 1,\r\n                            wordHints: newWordHints,\r\n                        };\r\n                    });\r\n\r\n                    if (mode === 'coop' && remaining !== undefined) {\r\n                        setHintsRemaining(remaining);\r\n                    }\r\n                }\r\n\r\n                if (callback) callback(response);\r\n            });\r\n        }\r\n    }, [socket, sessionId, mode]);\r\n\r\n    /**\r\n     * Check if a word is complete\r\n     */\r\n    const checkWordComplete = useCallback((wordIndex) => {\r\n        if (!gameState.crosswordData) return false;\r\n\r\n        const word = gameState.crosswordData.words[wordIndex];\r\n        const { row, col, direction, word: answer } = word;\r\n\r\n        for (let i = 0; i < answer.length; i++) {\r\n            const r = direction === 'across' ? row : row + i;\r\n            const c = direction === 'across' ? col + i : col;\r\n\r\n            if (gameState.grid[r][c] !== answer[i]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }, [gameState.grid, gameState.crosswordData]);\r\n\r\n    /**\r\n     * Mark word as complete\r\n     */\r\n    const completeWord = useCallback((wordIndex) => {\r\n        if (!gameState.crosswordData) return;\r\n\r\n        const word = gameState.crosswordData.words[wordIndex];\r\n        const hintsUsed = gameState.wordHints[wordIndex] || 0;\r\n\r\n        setGameState((prev) => ({\r\n            ...prev,\r\n            completedWords: [...prev.completedWords, { ...word, hintsUsed }],\r\n        }));\r\n\r\n        // Notify server\r\n        if (socket) {\r\n            socket.emit('word-complete', {\r\n                sessionId,\r\n                wordIndex,\r\n                elapsedTime: gameState.elapsedTime,\r\n            });\r\n        }\r\n    }, [socket, sessionId, gameState.crosswordData, gameState.wordHints, gameState.elapsedTime]);\r\n\r\n    /**\r\n     * Update elapsed time\r\n     */\r\n    const updateElapsedTime = useCallback((time) => {\r\n        setGameState((prev) => ({ ...prev, elapsedTime: time }));\r\n    }, []);\r\n\r\n    /**\r\n     * Complete game\r\n     */\r\n    const completeGame = useCallback((callback) => {\r\n        setGameState((prev) => ({ ...prev, status: 'completed' }));\r\n\r\n        if (socket) {\r\n            socket.emit('game-complete', {\r\n                sessionId,\r\n                completionTime: gameState.elapsedTime,\r\n            }, callback);\r\n        }\r\n    }, [socket, sessionId, gameState.elapsedTime]);\r\n\r\n    // Socket event listeners\r\n    useEffect(() => {\r\n        if (!socket) return;\r\n\r\n        // Cell updated (co-op mode)\r\n        socket.on('cell-updated', (data) => {\r\n            if (mode === 'coop') {\r\n                setGameState((prev) => {\r\n                    const newGrid = prev.grid.map((r) => [...r]);\r\n                    newGrid[data.row][data.col] = data.value;\r\n                    return { ...prev, grid: newGrid };\r\n                });\r\n            }\r\n        });\r\n\r\n        // Hint used (co-op mode)\r\n        socket.on('hint-used', (data) => {\r\n            if (mode === 'coop') {\r\n                setGameState((prev) => {\r\n                    const newGrid = prev.grid.map((r) => [...r]);\r\n                    newGrid[data.hint.row][data.hint.col] = data.hint.letter;\r\n                    return { ...prev, grid: newGrid };\r\n                });\r\n                setHintsRemaining(data.hintsRemaining);\r\n            }\r\n        });\r\n\r\n        // Leaderboard update (competitive mode)\r\n        socket.on('leaderboard-update', (data) => {\r\n            if (mode === 'competitive') {\r\n                setLeaderboard(data.leaderboard);\r\n            }\r\n        });\r\n\r\n        // Player joined\r\n        socket.on('player-joined', (data) => {\r\n            setPlayers((prev) => [...prev, data]);\r\n        });\r\n\r\n        // Player left\r\n        socket.on('player-left', (data) => {\r\n            setPlayers((prev) => prev.filter((p) => p.playerId !== data.playerId));\r\n        });\r\n\r\n        return () => {\r\n            socket.off('cell-updated');\r\n            socket.off('hint-used');\r\n            socket.off('leaderboard-update');\r\n            socket.off('player-joined');\r\n            socket.off('player-left');\r\n        };\r\n    }, [socket, mode]);\r\n\r\n    return {\r\n        gameState,\r\n        setGameState,\r\n        leaderboard,\r\n        players,\r\n        setPlayers,\r\n        hintsRemaining,\r\n        initializeGame,\r\n        updateCell,\r\n        requestHint,\r\n        checkWordComplete,\r\n        completeWord,\r\n        updateElapsedTime,\r\n        completeGame,\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}