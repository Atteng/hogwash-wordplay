{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Awaji-Iyaham Atteng\\\\Desktop\\\\multiplayer-crossword\\\\client\\\\src\\\\components\\\\CrosswordGrid.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport './CrosswordGrid.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction CrosswordGrid({\n  crosswordData,\n  gameState,\n  onCellUpdate,\n  mode\n}) {\n  _s();\n  const [selectedCell, setSelectedCell] = useState({\n    row: 0,\n    col: 0\n  });\n  const [direction, setDirection] = useState('across'); // across or down\n  const gridRef = useRef(null);\n  const {\n    grid,\n    crosswordData: data\n  } = gameState;\n\n  // Find word at current position - MOVED BEFORE EARLY RETURN\n  const findWordAtPosition = useCallback((row, col, dir) => {\n    if (!data || !data.words) return null;\n    return data.words.find(word => {\n      if (word.direction !== dir) return false;\n      if (dir === 'across') {\n        return word.row === row && col >= word.col && col < word.col + word.word.length;\n      } else {\n        return word.col === col && row >= word.row && row < word.row + word.word.length;\n      }\n    });\n  }, [data]);\n\n  // Handle keyboard input - MOVED BEFORE EARLY RETURN\n  const handleKeyDown = useCallback(e => {\n    if (!data || !data.dimensions) return;\n    const {\n      row,\n      col\n    } = selectedCell;\n    const {\n      dimensions\n    } = data;\n\n    // Letter input\n    if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {\n      e.preventDefault();\n      onCellUpdate(row, col, e.key.toUpperCase());\n\n      // Move to next cell\n      const currentWord = findWordAtPosition(row, col, direction);\n      if (currentWord) {\n        if (direction === 'across' && col < currentWord.col + currentWord.word.length - 1) {\n          setSelectedCell({\n            row,\n            col: col + 1\n          });\n        } else if (direction === 'down' && row < currentWord.row + currentWord.word.length - 1) {\n          setSelectedCell({\n            row: row + 1,\n            col\n          });\n        }\n      }\n    }\n\n    // Backspace\n    if (e.key === 'Backspace') {\n      e.preventDefault();\n      onCellUpdate(row, col, '');\n\n      // Move to previous cell\n      const currentWord = findWordAtPosition(row, col, direction);\n      if (currentWord) {\n        if (direction === 'across' && col > currentWord.col) {\n          setSelectedCell({\n            row,\n            col: col - 1\n          });\n        } else if (direction === 'down' && row > currentWord.row) {\n          setSelectedCell({\n            row: row - 1,\n            col\n          });\n        }\n      }\n    }\n\n    // Arrow keys\n    if (e.key === 'ArrowRight' && col < dimensions.cols - 1) {\n      e.preventDefault();\n      setSelectedCell({\n        row,\n        col: col + 1\n      });\n      setDirection('across');\n    }\n    if (e.key === 'ArrowLeft' && col > 0) {\n      e.preventDefault();\n      setSelectedCell({\n        row,\n        col: col - 1\n      });\n      setDirection('across');\n    }\n    if (e.key === 'ArrowDown' && row < dimensions.rows - 1) {\n      e.preventDefault();\n      setSelectedCell({\n        row: row + 1,\n        col\n      });\n      setDirection('down');\n    }\n    if (e.key === 'ArrowUp' && row > 0) {\n      e.preventDefault();\n      setSelectedCell({\n        row: row - 1,\n        col\n      });\n      setDirection('down');\n    }\n\n    // Space to toggle direction\n    if (e.key === ' ') {\n      e.preventDefault();\n      setDirection(prev => prev === 'across' ? 'down' : 'across');\n    }\n  }, [selectedCell, direction, data, onCellUpdate, findWordAtPosition]);\n\n  // Effect for keyboard events - MOVED BEFORE EARLY RETURN\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Early return AFTER all hooks\n  if (!data || !grid) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"Loading grid...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 101,\n      columnNumber: 16\n    }, this);\n  }\n  const {\n    dimensions,\n    words\n  } = data;\n\n  // Handle cell click\n  const handleCellClick = (row, col) => {\n    // Check if cell is part of a word\n    const isPartOfWord = words.some(word => {\n      if (word.direction === 'across') {\n        return word.row === row && col >= word.col && col < word.col + word.word.length;\n      } else {\n        return word.col === col && row >= word.row && row < word.row + word.word.length;\n      }\n    });\n    if (!isPartOfWord) return;\n\n    // If clicking the same cell, toggle direction\n    if (selectedCell.row === row && selectedCell.col === col) {\n      setDirection(prev => prev === 'across' ? 'down' : 'across');\n    } else {\n      setSelectedCell({\n        row,\n        col\n      });\n      // Auto-detect direction based on available words\n      const hasAcross = findWordAtPosition(row, col, 'across');\n      const hasDown = findWordAtPosition(row, col, 'down');\n      if (hasAcross && !hasDown) setDirection('across');else if (hasDown && !hasAcross) setDirection('down');\n    }\n  };\n\n  // Check if cell is part of current word\n  const isInCurrentWord = (row, col) => {\n    const currentWord = findWordAtPosition(selectedCell.row, selectedCell.col, direction);\n    if (!currentWord) return false;\n    if (direction === 'across') {\n      return row === currentWord.row && col >= currentWord.col && col < currentWord.col + currentWord.word.length;\n    } else {\n      return col === currentWord.col && row >= currentWord.row && row < currentWord.row + currentWord.word.length;\n    }\n  };\n\n  // Get cell number (for clue references)\n  const getCellNumber = (row, col) => {\n    const word = words.find(w => w.row === row && w.col === col);\n    return word ? word.number : null;\n  };\n\n  // Check if cell is part of any word\n  const isPartOfWord = (row, col) => {\n    return words.some(word => {\n      if (word.direction === 'across') {\n        return word.row === row && col >= word.col && col < word.col + word.word.length;\n      } else {\n        return word.col === col && row >= word.row && row < word.row + word.word.length;\n      }\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"crossword-grid-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"crossword-grid\",\n      ref: gridRef,\n      style: {\n        gridTemplateColumns: `repeat(${dimensions.cols}, 1fr)`,\n        gridTemplateRows: `repeat(${dimensions.rows}, 1fr)`\n      },\n      children: grid.map((row, rowIndex) => row.map((cell, colIndex) => {\n        const cellNumber = getCellNumber(rowIndex, colIndex);\n        const isSelected = selectedCell.row === rowIndex && selectedCell.col === colIndex;\n        const isHighlighted = isInCurrentWord(rowIndex, colIndex);\n        const isWord = isPartOfWord(rowIndex, colIndex);\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `crossword-cell ${isWord ? 'word-cell' : 'blocked-cell'} ${isSelected ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}`,\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: [cellNumber && /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"cell-number\",\n            children: cellNumber\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 185,\n            columnNumber: 48\n          }, this), isWord && /*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"text\",\n            className: \"cell-input\",\n            value: cell || '',\n            maxLength: 1,\n            readOnly: true,\n            tabIndex: -1\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 187,\n            columnNumber: 37\n          }, this)]\n        }, `${rowIndex}-${colIndex}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 179,\n          columnNumber: 29\n        }, this);\n      }))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-instructions\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"Controls:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 203,\n          columnNumber: 21\n        }, this), \" Click a cell, type letters, use arrow keys to navigate, Space to toggle direction\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 202,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 162,\n    columnNumber: 9\n  }, this);\n}\n_s(CrosswordGrid, \"K4n3Kb41Xkp/LexXbaZA+fE+3fU=\");\n_c = CrosswordGrid;\nexport default CrosswordGrid;\nvar _c;\n$RefreshReg$(_c, \"CrosswordGrid\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","jsxDEV","_jsxDEV","CrosswordGrid","crosswordData","gameState","onCellUpdate","mode","_s","selectedCell","setSelectedCell","row","col","direction","setDirection","gridRef","grid","data","findWordAtPosition","dir","words","find","word","length","handleKeyDown","e","dimensions","key","match","preventDefault","toUpperCase","currentWord","cols","rows","prev","window","addEventListener","removeEventListener","children","fileName","_jsxFileName","lineNumber","columnNumber","handleCellClick","isPartOfWord","some","hasAcross","hasDown","isInCurrentWord","getCellNumber","w","number","className","ref","style","gridTemplateColumns","gridTemplateRows","map","rowIndex","cell","colIndex","cellNumber","isSelected","isHighlighted","isWord","onClick","type","value","maxLength","readOnly","tabIndex","_c","$RefreshReg$"],"sources":["C:/Users/Awaji-Iyaham Atteng/Desktop/multiplayer-crossword/client/src/components/CrosswordGrid.jsx"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\r\nimport './CrosswordGrid.css';\r\n\r\nfunction CrosswordGrid({ crosswordData, gameState, onCellUpdate, mode }) {\r\n    const [selectedCell, setSelectedCell] = useState({ row: 0, col: 0 });\r\n    const [direction, setDirection] = useState('across'); // across or down\r\n    const gridRef = useRef(null);\r\n\r\n    const { grid, crosswordData: data } = gameState;\r\n\r\n    // Find word at current position - MOVED BEFORE EARLY RETURN\r\n    const findWordAtPosition = useCallback((row, col, dir) => {\r\n        if (!data || !data.words) return null;\r\n        return data.words.find(word => {\r\n            if (word.direction !== dir) return false;\r\n\r\n            if (dir === 'across') {\r\n                return word.row === row && col >= word.col && col < word.col + word.word.length;\r\n            } else {\r\n                return word.col === col && row >= word.row && row < word.row + word.word.length;\r\n            }\r\n        });\r\n    }, [data]);\r\n\r\n    // Handle keyboard input - MOVED BEFORE EARLY RETURN\r\n    const handleKeyDown = useCallback((e) => {\r\n        if (!data || !data.dimensions) return;\r\n\r\n        const { row, col } = selectedCell;\r\n        const { dimensions } = data;\r\n\r\n        // Letter input\r\n        if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {\r\n            e.preventDefault();\r\n            onCellUpdate(row, col, e.key.toUpperCase());\r\n\r\n            // Move to next cell\r\n            const currentWord = findWordAtPosition(row, col, direction);\r\n            if (currentWord) {\r\n                if (direction === 'across' && col < currentWord.col + currentWord.word.length - 1) {\r\n                    setSelectedCell({ row, col: col + 1 });\r\n                } else if (direction === 'down' && row < currentWord.row + currentWord.word.length - 1) {\r\n                    setSelectedCell({ row: row + 1, col });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Backspace\r\n        if (e.key === 'Backspace') {\r\n            e.preventDefault();\r\n            onCellUpdate(row, col, '');\r\n\r\n            // Move to previous cell\r\n            const currentWord = findWordAtPosition(row, col, direction);\r\n            if (currentWord) {\r\n                if (direction === 'across' && col > currentWord.col) {\r\n                    setSelectedCell({ row, col: col - 1 });\r\n                } else if (direction === 'down' && row > currentWord.row) {\r\n                    setSelectedCell({ row: row - 1, col });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Arrow keys\r\n        if (e.key === 'ArrowRight' && col < dimensions.cols - 1) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row, col: col + 1 });\r\n            setDirection('across');\r\n        }\r\n        if (e.key === 'ArrowLeft' && col > 0) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row, col: col - 1 });\r\n            setDirection('across');\r\n        }\r\n        if (e.key === 'ArrowDown' && row < dimensions.rows - 1) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row: row + 1, col });\r\n            setDirection('down');\r\n        }\r\n        if (e.key === 'ArrowUp' && row > 0) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row: row - 1, col });\r\n            setDirection('down');\r\n        }\r\n\r\n        // Space to toggle direction\r\n        if (e.key === ' ') {\r\n            e.preventDefault();\r\n            setDirection(prev => prev === 'across' ? 'down' : 'across');\r\n        }\r\n    }, [selectedCell, direction, data, onCellUpdate, findWordAtPosition]);\r\n\r\n    // Effect for keyboard events - MOVED BEFORE EARLY RETURN\r\n    useEffect(() => {\r\n        window.addEventListener('keydown', handleKeyDown);\r\n        return () => window.removeEventListener('keydown', handleKeyDown);\r\n    }, [handleKeyDown]);\r\n\r\n    // Early return AFTER all hooks\r\n    if (!data || !grid) {\r\n        return <div>Loading grid...</div>;\r\n    }\r\n\r\n    const { dimensions, words } = data;\r\n\r\n    // Handle cell click\r\n    const handleCellClick = (row, col) => {\r\n        // Check if cell is part of a word\r\n        const isPartOfWord = words.some(word => {\r\n            if (word.direction === 'across') {\r\n                return word.row === row && col >= word.col && col < word.col + word.word.length;\r\n            } else {\r\n                return word.col === col && row >= word.row && row < word.row + word.word.length;\r\n            }\r\n        });\r\n\r\n        if (!isPartOfWord) return;\r\n\r\n        // If clicking the same cell, toggle direction\r\n        if (selectedCell.row === row && selectedCell.col === col) {\r\n            setDirection(prev => prev === 'across' ? 'down' : 'across');\r\n        } else {\r\n            setSelectedCell({ row, col });\r\n            // Auto-detect direction based on available words\r\n            const hasAcross = findWordAtPosition(row, col, 'across');\r\n            const hasDown = findWordAtPosition(row, col, 'down');\r\n            if (hasAcross && !hasDown) setDirection('across');\r\n            else if (hasDown && !hasAcross) setDirection('down');\r\n        }\r\n    };\r\n\r\n    // Check if cell is part of current word\r\n    const isInCurrentWord = (row, col) => {\r\n        const currentWord = findWordAtPosition(selectedCell.row, selectedCell.col, direction);\r\n        if (!currentWord) return false;\r\n\r\n        if (direction === 'across') {\r\n            return row === currentWord.row && col >= currentWord.col && col < currentWord.col + currentWord.word.length;\r\n        } else {\r\n            return col === currentWord.col && row >= currentWord.row && row < currentWord.row + currentWord.word.length;\r\n        }\r\n    };\r\n\r\n    // Get cell number (for clue references)\r\n    const getCellNumber = (row, col) => {\r\n        const word = words.find(w => w.row === row && w.col === col);\r\n        return word ? word.number : null;\r\n    };\r\n\r\n    // Check if cell is part of any word\r\n    const isPartOfWord = (row, col) => {\r\n        return words.some(word => {\r\n            if (word.direction === 'across') {\r\n                return word.row === row && col >= word.col && col < word.col + word.word.length;\r\n            } else {\r\n                return word.col === col && row >= word.row && row < word.row + word.word.length;\r\n            }\r\n        });\r\n    };\r\n\r\n    return (\r\n        <div className=\"crossword-grid-container\">\r\n            <div\r\n                className=\"crossword-grid\"\r\n                ref={gridRef}\r\n                style={{\r\n                    gridTemplateColumns: `repeat(${dimensions.cols}, 1fr)`,\r\n                    gridTemplateRows: `repeat(${dimensions.rows}, 1fr)`,\r\n                }}\r\n            >\r\n                {grid.map((row, rowIndex) =>\r\n                    row.map((cell, colIndex) => {\r\n                        const cellNumber = getCellNumber(rowIndex, colIndex);\r\n                        const isSelected = selectedCell.row === rowIndex && selectedCell.col === colIndex;\r\n                        const isHighlighted = isInCurrentWord(rowIndex, colIndex);\r\n                        const isWord = isPartOfWord(rowIndex, colIndex);\r\n\r\n                        return (\r\n                            <div\r\n                                key={`${rowIndex}-${colIndex}`}\r\n                                className={`crossword-cell ${isWord ? 'word-cell' : 'blocked-cell'} ${isSelected ? 'selected' : ''\r\n                                    } ${isHighlighted ? 'highlighted' : ''}`}\r\n                                onClick={() => handleCellClick(rowIndex, colIndex)}\r\n                            >\r\n                                {cellNumber && <span className=\"cell-number\">{cellNumber}</span>}\r\n                                {isWord && (\r\n                                    <input\r\n                                        type=\"text\"\r\n                                        className=\"cell-input\"\r\n                                        value={cell || ''}\r\n                                        maxLength={1}\r\n                                        readOnly\r\n                                        tabIndex={-1}\r\n                                    />\r\n                                )}\r\n                            </div>\r\n                        );\r\n                    })\r\n                )}\r\n            </div>\r\n            <div className=\"grid-instructions\">\r\n                <p>\r\n                    <strong>Controls:</strong> Click a cell, type letters, use arrow keys to navigate,\r\n                    Space to toggle direction\r\n                </p>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CrosswordGrid;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}