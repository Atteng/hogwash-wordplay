{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Awaji-Iyaham Atteng\\\\Desktop\\\\multiplayer-crossword\\\\client\\\\src\\\\components\\\\CrosswordGrid.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport './CrosswordGrid.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction CrosswordGrid({\n  crosswordData,\n  gameState,\n  onCellUpdate,\n  mode\n}) {\n  _s();\n  const [selectedCell, setSelectedCell] = useState({\n    row: 0,\n    col: 0\n  });\n  const [direction, setDirection] = useState('across'); // across or down\n  const gridRef = useRef(null);\n  const {\n    grid,\n    crosswordData: data\n  } = gameState;\n  if (!data || !grid) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"Loading grid...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 16\n    }, this);\n  }\n  const {\n    dimensions,\n    words\n  } = data;\n\n  // Find word at current position\n  const findWordAtPosition = useCallback((row, col, dir) => {\n    return words.find(word => {\n      if (word.direction !== dir) return false;\n      if (dir === 'across') {\n        return word.row === row && col >= word.col && col < word.col + word.word.length;\n      } else {\n        return word.col === col && row >= word.row && row < word.row + word.word.length;\n      }\n    });\n  }, [words]);\n\n  // Handle cell click\n  const handleCellClick = (row, col) => {\n    // Check if cell is part of a word\n    const isPartOfWord = words.some(word => {\n      if (word.direction === 'across') {\n        return word.row === row && col >= word.col && col < word.col + word.word.length;\n      } else {\n        return word.col === col && row >= word.row && row < word.row + word.word.length;\n      }\n    });\n    if (!isPartOfWord) return;\n\n    // If clicking the same cell, toggle direction\n    if (selectedCell.row === row && selectedCell.col === col) {\n      setDirection(prev => prev === 'across' ? 'down' : 'across');\n    } else {\n      setSelectedCell({\n        row,\n        col\n      });\n      // Auto-detect direction based on available words\n      const hasAcross = findWordAtPosition(row, col, 'across');\n      const hasDown = findWordAtPosition(row, col, 'down');\n      if (hasAcross && !hasDown) setDirection('across');else if (hasDown && !hasAcross) setDirection('down');\n    }\n  };\n\n  // Handle keyboard input\n  const handleKeyDown = useCallback(e => {\n    const {\n      row,\n      col\n    } = selectedCell;\n\n    // Letter input\n    if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {\n      e.preventDefault();\n      onCellUpdate(row, col, e.key.toUpperCase());\n\n      // Move to next cell\n      const currentWord = findWordAtPosition(row, col, direction);\n      if (currentWord) {\n        if (direction === 'across' && col < currentWord.col + currentWord.word.length - 1) {\n          setSelectedCell({\n            row,\n            col: col + 1\n          });\n        } else if (direction === 'down' && row < currentWord.row + currentWord.word.length - 1) {\n          setSelectedCell({\n            row: row + 1,\n            col\n          });\n        }\n      }\n    }\n\n    // Backspace\n    if (e.key === 'Backspace') {\n      e.preventDefault();\n      onCellUpdate(row, col, '');\n\n      // Move to previous cell\n      const currentWord = findWordAtPosition(row, col, direction);\n      if (currentWord) {\n        if (direction === 'across' && col > currentWord.col) {\n          setSelectedCell({\n            row,\n            col: col - 1\n          });\n        } else if (direction === 'down' && row > currentWord.row) {\n          setSelectedCell({\n            row: row - 1,\n            col\n          });\n        }\n      }\n    }\n\n    // Arrow keys\n    if (e.key === 'ArrowRight' && col < dimensions.cols - 1) {\n      e.preventDefault();\n      setSelectedCell({\n        row,\n        col: col + 1\n      });\n      setDirection('across');\n    }\n    if (e.key === 'ArrowLeft' && col > 0) {\n      e.preventDefault();\n      setSelectedCell({\n        row,\n        col: col - 1\n      });\n      setDirection('across');\n    }\n    if (e.key === 'ArrowDown' && row < dimensions.rows - 1) {\n      e.preventDefault();\n      setSelectedCell({\n        row: row + 1,\n        col\n      });\n      setDirection('down');\n    }\n    if (e.key === 'ArrowUp' && row > 0) {\n      e.preventDefault();\n      setSelectedCell({\n        row: row - 1,\n        col\n      });\n      setDirection('down');\n    }\n\n    // Space to toggle direction\n    if (e.key === ' ') {\n      e.preventDefault();\n      setDirection(prev => prev === 'across' ? 'down' : 'across');\n    }\n  }, [selectedCell, direction, dimensions, onCellUpdate, findWordAtPosition]);\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [handleKeyDown]);\n\n  // Check if cell is part of current word\n  const isInCurrentWord = (row, col) => {\n    const currentWord = findWordAtPosition(selectedCell.row, selectedCell.col, direction);\n    if (!currentWord) return false;\n    if (direction === 'across') {\n      return row === currentWord.row && col >= currentWord.col && col < currentWord.col + currentWord.word.length;\n    } else {\n      return col === currentWord.col && row >= currentWord.row && row < currentWord.row + currentWord.word.length;\n    }\n  };\n\n  // Get cell number (for clue references)\n  const getCellNumber = (row, col) => {\n    const word = words.find(w => w.row === row && w.col === col);\n    return word ? word.number : null;\n  };\n\n  // Check if cell is part of any word\n  const isPartOfWord = (row, col) => {\n    return words.some(word => {\n      if (word.direction === 'across') {\n        return word.row === row && col >= word.col && col < word.col + word.word.length;\n      } else {\n        return word.col === col && row >= word.row && row < word.row + word.word.length;\n      }\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"crossword-grid-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"crossword-grid\",\n      ref: gridRef,\n      style: {\n        gridTemplateColumns: `repeat(${dimensions.cols}, 1fr)`,\n        gridTemplateRows: `repeat(${dimensions.rows}, 1fr)`\n      },\n      children: grid.map((row, rowIndex) => row.map((cell, colIndex) => {\n        const cellNumber = getCellNumber(rowIndex, colIndex);\n        const isSelected = selectedCell.row === rowIndex && selectedCell.col === colIndex;\n        const isHighlighted = isInCurrentWord(rowIndex, colIndex);\n        const isWord = isPartOfWord(rowIndex, colIndex);\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `crossword-cell ${isWord ? 'word-cell' : 'blocked-cell'} ${isSelected ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}`,\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: [cellNumber && /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"cell-number\",\n            children: cellNumber\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 179,\n            columnNumber: 48\n          }, this), isWord && /*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"text\",\n            className: \"cell-input\",\n            value: cell || '',\n            maxLength: 1,\n            readOnly: true,\n            tabIndex: -1\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 181,\n            columnNumber: 37\n          }, this)]\n        }, `${rowIndex}-${colIndex}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 173,\n          columnNumber: 29\n        }, this);\n      }))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid-instructions\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"Controls:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 197,\n          columnNumber: 21\n        }, this), \" Click a cell, type letters, use arrow keys to navigate, Space to toggle direction\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 156,\n    columnNumber: 9\n  }, this);\n}\n_s(CrosswordGrid, \"K4n3Kb41Xkp/LexXbaZA+fE+3fU=\");\n_c = CrosswordGrid;\nexport default CrosswordGrid;\nvar _c;\n$RefreshReg$(_c, \"CrosswordGrid\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","jsxDEV","_jsxDEV","CrosswordGrid","crosswordData","gameState","onCellUpdate","mode","_s","selectedCell","setSelectedCell","row","col","direction","setDirection","gridRef","grid","data","children","fileName","_jsxFileName","lineNumber","columnNumber","dimensions","words","findWordAtPosition","dir","find","word","length","handleCellClick","isPartOfWord","some","prev","hasAcross","hasDown","handleKeyDown","e","key","match","preventDefault","toUpperCase","currentWord","cols","rows","window","addEventListener","removeEventListener","isInCurrentWord","getCellNumber","w","number","className","ref","style","gridTemplateColumns","gridTemplateRows","map","rowIndex","cell","colIndex","cellNumber","isSelected","isHighlighted","isWord","onClick","type","value","maxLength","readOnly","tabIndex","_c","$RefreshReg$"],"sources":["C:/Users/Awaji-Iyaham Atteng/Desktop/multiplayer-crossword/client/src/components/CrosswordGrid.jsx"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\r\nimport './CrosswordGrid.css';\r\n\r\nfunction CrosswordGrid({ crosswordData, gameState, onCellUpdate, mode }) {\r\n    const [selectedCell, setSelectedCell] = useState({ row: 0, col: 0 });\r\n    const [direction, setDirection] = useState('across'); // across or down\r\n    const gridRef = useRef(null);\r\n\r\n    const { grid, crosswordData: data } = gameState;\r\n\r\n    if (!data || !grid) {\r\n        return <div>Loading grid...</div>;\r\n    }\r\n\r\n    const { dimensions, words } = data;\r\n\r\n    // Find word at current position\r\n    const findWordAtPosition = useCallback((row, col, dir) => {\r\n        return words.find(word => {\r\n            if (word.direction !== dir) return false;\r\n\r\n            if (dir === 'across') {\r\n                return word.row === row && col >= word.col && col < word.col + word.word.length;\r\n            } else {\r\n                return word.col === col && row >= word.row && row < word.row + word.word.length;\r\n            }\r\n        });\r\n    }, [words]);\r\n\r\n    // Handle cell click\r\n    const handleCellClick = (row, col) => {\r\n        // Check if cell is part of a word\r\n        const isPartOfWord = words.some(word => {\r\n            if (word.direction === 'across') {\r\n                return word.row === row && col >= word.col && col < word.col + word.word.length;\r\n            } else {\r\n                return word.col === col && row >= word.row && row < word.row + word.word.length;\r\n            }\r\n        });\r\n\r\n        if (!isPartOfWord) return;\r\n\r\n        // If clicking the same cell, toggle direction\r\n        if (selectedCell.row === row && selectedCell.col === col) {\r\n            setDirection(prev => prev === 'across' ? 'down' : 'across');\r\n        } else {\r\n            setSelectedCell({ row, col });\r\n            // Auto-detect direction based on available words\r\n            const hasAcross = findWordAtPosition(row, col, 'across');\r\n            const hasDown = findWordAtPosition(row, col, 'down');\r\n            if (hasAcross && !hasDown) setDirection('across');\r\n            else if (hasDown && !hasAcross) setDirection('down');\r\n        }\r\n    };\r\n\r\n    // Handle keyboard input\r\n    const handleKeyDown = useCallback((e) => {\r\n        const { row, col } = selectedCell;\r\n\r\n        // Letter input\r\n        if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {\r\n            e.preventDefault();\r\n            onCellUpdate(row, col, e.key.toUpperCase());\r\n\r\n            // Move to next cell\r\n            const currentWord = findWordAtPosition(row, col, direction);\r\n            if (currentWord) {\r\n                if (direction === 'across' && col < currentWord.col + currentWord.word.length - 1) {\r\n                    setSelectedCell({ row, col: col + 1 });\r\n                } else if (direction === 'down' && row < currentWord.row + currentWord.word.length - 1) {\r\n                    setSelectedCell({ row: row + 1, col });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Backspace\r\n        if (e.key === 'Backspace') {\r\n            e.preventDefault();\r\n            onCellUpdate(row, col, '');\r\n\r\n            // Move to previous cell\r\n            const currentWord = findWordAtPosition(row, col, direction);\r\n            if (currentWord) {\r\n                if (direction === 'across' && col > currentWord.col) {\r\n                    setSelectedCell({ row, col: col - 1 });\r\n                } else if (direction === 'down' && row > currentWord.row) {\r\n                    setSelectedCell({ row: row - 1, col });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Arrow keys\r\n        if (e.key === 'ArrowRight' && col < dimensions.cols - 1) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row, col: col + 1 });\r\n            setDirection('across');\r\n        }\r\n        if (e.key === 'ArrowLeft' && col > 0) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row, col: col - 1 });\r\n            setDirection('across');\r\n        }\r\n        if (e.key === 'ArrowDown' && row < dimensions.rows - 1) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row: row + 1, col });\r\n            setDirection('down');\r\n        }\r\n        if (e.key === 'ArrowUp' && row > 0) {\r\n            e.preventDefault();\r\n            setSelectedCell({ row: row - 1, col });\r\n            setDirection('down');\r\n        }\r\n\r\n        // Space to toggle direction\r\n        if (e.key === ' ') {\r\n            e.preventDefault();\r\n            setDirection(prev => prev === 'across' ? 'down' : 'across');\r\n        }\r\n    }, [selectedCell, direction, dimensions, onCellUpdate, findWordAtPosition]);\r\n\r\n    useEffect(() => {\r\n        window.addEventListener('keydown', handleKeyDown);\r\n        return () => window.removeEventListener('keydown', handleKeyDown);\r\n    }, [handleKeyDown]);\r\n\r\n    // Check if cell is part of current word\r\n    const isInCurrentWord = (row, col) => {\r\n        const currentWord = findWordAtPosition(selectedCell.row, selectedCell.col, direction);\r\n        if (!currentWord) return false;\r\n\r\n        if (direction === 'across') {\r\n            return row === currentWord.row && col >= currentWord.col && col < currentWord.col + currentWord.word.length;\r\n        } else {\r\n            return col === currentWord.col && row >= currentWord.row && row < currentWord.row + currentWord.word.length;\r\n        }\r\n    };\r\n\r\n    // Get cell number (for clue references)\r\n    const getCellNumber = (row, col) => {\r\n        const word = words.find(w => w.row === row && w.col === col);\r\n        return word ? word.number : null;\r\n    };\r\n\r\n    // Check if cell is part of any word\r\n    const isPartOfWord = (row, col) => {\r\n        return words.some(word => {\r\n            if (word.direction === 'across') {\r\n                return word.row === row && col >= word.col && col < word.col + word.word.length;\r\n            } else {\r\n                return word.col === col && row >= word.row && row < word.row + word.word.length;\r\n            }\r\n        });\r\n    };\r\n\r\n    return (\r\n        <div className=\"crossword-grid-container\">\r\n            <div\r\n                className=\"crossword-grid\"\r\n                ref={gridRef}\r\n                style={{\r\n                    gridTemplateColumns: `repeat(${dimensions.cols}, 1fr)`,\r\n                    gridTemplateRows: `repeat(${dimensions.rows}, 1fr)`,\r\n                }}\r\n            >\r\n                {grid.map((row, rowIndex) =>\r\n                    row.map((cell, colIndex) => {\r\n                        const cellNumber = getCellNumber(rowIndex, colIndex);\r\n                        const isSelected = selectedCell.row === rowIndex && selectedCell.col === colIndex;\r\n                        const isHighlighted = isInCurrentWord(rowIndex, colIndex);\r\n                        const isWord = isPartOfWord(rowIndex, colIndex);\r\n\r\n                        return (\r\n                            <div\r\n                                key={`${rowIndex}-${colIndex}`}\r\n                                className={`crossword-cell ${isWord ? 'word-cell' : 'blocked-cell'} ${isSelected ? 'selected' : ''\r\n                                    } ${isHighlighted ? 'highlighted' : ''}`}\r\n                                onClick={() => handleCellClick(rowIndex, colIndex)}\r\n                            >\r\n                                {cellNumber && <span className=\"cell-number\">{cellNumber}</span>}\r\n                                {isWord && (\r\n                                    <input\r\n                                        type=\"text\"\r\n                                        className=\"cell-input\"\r\n                                        value={cell || ''}\r\n                                        maxLength={1}\r\n                                        readOnly\r\n                                        tabIndex={-1}\r\n                                    />\r\n                                )}\r\n                            </div>\r\n                        );\r\n                    })\r\n                )}\r\n            </div>\r\n            <div className=\"grid-instructions\">\r\n                <p>\r\n                    <strong>Controls:</strong> Click a cell, type letters, use arrow keys to navigate,\r\n                    Space to toggle direction\r\n                </p>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CrosswordGrid;\r\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,WAAW,EAAEC,MAAM,QAAQ,OAAO;AACvE,OAAO,qBAAqB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE7B,SAASC,aAAaA,CAAC;EAAEC,aAAa;EAAEC,SAAS;EAAEC,YAAY;EAAEC;AAAK,CAAC,EAAE;EAAAC,EAAA;EACrE,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGb,QAAQ,CAAC;IAAEc,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC,CAAC;EACpE,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGjB,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;EACtD,MAAMkB,OAAO,GAAGf,MAAM,CAAC,IAAI,CAAC;EAE5B,MAAM;IAAEgB,IAAI;IAAEZ,aAAa,EAAEa;EAAK,CAAC,GAAGZ,SAAS;EAE/C,IAAI,CAACY,IAAI,IAAI,CAACD,IAAI,EAAE;IAChB,oBAAOd,OAAA;MAAAgB,QAAA,EAAK;IAAe;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK,CAAC;EACrC;EAEA,MAAM;IAAEC,UAAU;IAAEC;EAAM,CAAC,GAAGP,IAAI;;EAElC;EACA,MAAMQ,kBAAkB,GAAG1B,WAAW,CAAC,CAACY,GAAG,EAAEC,GAAG,EAAEc,GAAG,KAAK;IACtD,OAAOF,KAAK,CAACG,IAAI,CAACC,IAAI,IAAI;MACtB,IAAIA,IAAI,CAACf,SAAS,KAAKa,GAAG,EAAE,OAAO,KAAK;MAExC,IAAIA,GAAG,KAAK,QAAQ,EAAE;QAClB,OAAOE,IAAI,CAACjB,GAAG,KAAKA,GAAG,IAAIC,GAAG,IAAIgB,IAAI,CAAChB,GAAG,IAAIA,GAAG,GAAGgB,IAAI,CAAChB,GAAG,GAAGgB,IAAI,CAACA,IAAI,CAACC,MAAM;MACnF,CAAC,MAAM;QACH,OAAOD,IAAI,CAAChB,GAAG,KAAKA,GAAG,IAAID,GAAG,IAAIiB,IAAI,CAACjB,GAAG,IAAIA,GAAG,GAAGiB,IAAI,CAACjB,GAAG,GAAGiB,IAAI,CAACA,IAAI,CAACC,MAAM;MACnF;IACJ,CAAC,CAAC;EACN,CAAC,EAAE,CAACL,KAAK,CAAC,CAAC;;EAEX;EACA,MAAMM,eAAe,GAAGA,CAACnB,GAAG,EAAEC,GAAG,KAAK;IAClC;IACA,MAAMmB,YAAY,GAAGP,KAAK,CAACQ,IAAI,CAACJ,IAAI,IAAI;MACpC,IAAIA,IAAI,CAACf,SAAS,KAAK,QAAQ,EAAE;QAC7B,OAAOe,IAAI,CAACjB,GAAG,KAAKA,GAAG,IAAIC,GAAG,IAAIgB,IAAI,CAAChB,GAAG,IAAIA,GAAG,GAAGgB,IAAI,CAAChB,GAAG,GAAGgB,IAAI,CAACA,IAAI,CAACC,MAAM;MACnF,CAAC,MAAM;QACH,OAAOD,IAAI,CAAChB,GAAG,KAAKA,GAAG,IAAID,GAAG,IAAIiB,IAAI,CAACjB,GAAG,IAAIA,GAAG,GAAGiB,IAAI,CAACjB,GAAG,GAAGiB,IAAI,CAACA,IAAI,CAACC,MAAM;MACnF;IACJ,CAAC,CAAC;IAEF,IAAI,CAACE,YAAY,EAAE;;IAEnB;IACA,IAAItB,YAAY,CAACE,GAAG,KAAKA,GAAG,IAAIF,YAAY,CAACG,GAAG,KAAKA,GAAG,EAAE;MACtDE,YAAY,CAACmB,IAAI,IAAIA,IAAI,KAAK,QAAQ,GAAG,MAAM,GAAG,QAAQ,CAAC;IAC/D,CAAC,MAAM;MACHvB,eAAe,CAAC;QAAEC,GAAG;QAAEC;MAAI,CAAC,CAAC;MAC7B;MACA,MAAMsB,SAAS,GAAGT,kBAAkB,CAACd,GAAG,EAAEC,GAAG,EAAE,QAAQ,CAAC;MACxD,MAAMuB,OAAO,GAAGV,kBAAkB,CAACd,GAAG,EAAEC,GAAG,EAAE,MAAM,CAAC;MACpD,IAAIsB,SAAS,IAAI,CAACC,OAAO,EAAErB,YAAY,CAAC,QAAQ,CAAC,CAAC,KAC7C,IAAIqB,OAAO,IAAI,CAACD,SAAS,EAAEpB,YAAY,CAAC,MAAM,CAAC;IACxD;EACJ,CAAC;;EAED;EACA,MAAMsB,aAAa,GAAGrC,WAAW,CAAEsC,CAAC,IAAK;IACrC,MAAM;MAAE1B,GAAG;MAAEC;IAAI,CAAC,GAAGH,YAAY;;IAEjC;IACA,IAAI4B,CAAC,CAACC,GAAG,CAACT,MAAM,KAAK,CAAC,IAAIQ,CAAC,CAACC,GAAG,CAACC,KAAK,CAAC,UAAU,CAAC,EAAE;MAC/CF,CAAC,CAACG,cAAc,CAAC,CAAC;MAClBlC,YAAY,CAACK,GAAG,EAAEC,GAAG,EAAEyB,CAAC,CAACC,GAAG,CAACG,WAAW,CAAC,CAAC,CAAC;;MAE3C;MACA,MAAMC,WAAW,GAAGjB,kBAAkB,CAACd,GAAG,EAAEC,GAAG,EAAEC,SAAS,CAAC;MAC3D,IAAI6B,WAAW,EAAE;QACb,IAAI7B,SAAS,KAAK,QAAQ,IAAID,GAAG,GAAG8B,WAAW,CAAC9B,GAAG,GAAG8B,WAAW,CAACd,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE;UAC/EnB,eAAe,CAAC;YAAEC,GAAG;YAAEC,GAAG,EAAEA,GAAG,GAAG;UAAE,CAAC,CAAC;QAC1C,CAAC,MAAM,IAAIC,SAAS,KAAK,MAAM,IAAIF,GAAG,GAAG+B,WAAW,CAAC/B,GAAG,GAAG+B,WAAW,CAACd,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE;UACpFnB,eAAe,CAAC;YAAEC,GAAG,EAAEA,GAAG,GAAG,CAAC;YAAEC;UAAI,CAAC,CAAC;QAC1C;MACJ;IACJ;;IAEA;IACA,IAAIyB,CAAC,CAACC,GAAG,KAAK,WAAW,EAAE;MACvBD,CAAC,CAACG,cAAc,CAAC,CAAC;MAClBlC,YAAY,CAACK,GAAG,EAAEC,GAAG,EAAE,EAAE,CAAC;;MAE1B;MACA,MAAM8B,WAAW,GAAGjB,kBAAkB,CAACd,GAAG,EAAEC,GAAG,EAAEC,SAAS,CAAC;MAC3D,IAAI6B,WAAW,EAAE;QACb,IAAI7B,SAAS,KAAK,QAAQ,IAAID,GAAG,GAAG8B,WAAW,CAAC9B,GAAG,EAAE;UACjDF,eAAe,CAAC;YAAEC,GAAG;YAAEC,GAAG,EAAEA,GAAG,GAAG;UAAE,CAAC,CAAC;QAC1C,CAAC,MAAM,IAAIC,SAAS,KAAK,MAAM,IAAIF,GAAG,GAAG+B,WAAW,CAAC/B,GAAG,EAAE;UACtDD,eAAe,CAAC;YAAEC,GAAG,EAAEA,GAAG,GAAG,CAAC;YAAEC;UAAI,CAAC,CAAC;QAC1C;MACJ;IACJ;;IAEA;IACA,IAAIyB,CAAC,CAACC,GAAG,KAAK,YAAY,IAAI1B,GAAG,GAAGW,UAAU,CAACoB,IAAI,GAAG,CAAC,EAAE;MACrDN,CAAC,CAACG,cAAc,CAAC,CAAC;MAClB9B,eAAe,CAAC;QAAEC,GAAG;QAAEC,GAAG,EAAEA,GAAG,GAAG;MAAE,CAAC,CAAC;MACtCE,YAAY,CAAC,QAAQ,CAAC;IAC1B;IACA,IAAIuB,CAAC,CAACC,GAAG,KAAK,WAAW,IAAI1B,GAAG,GAAG,CAAC,EAAE;MAClCyB,CAAC,CAACG,cAAc,CAAC,CAAC;MAClB9B,eAAe,CAAC;QAAEC,GAAG;QAAEC,GAAG,EAAEA,GAAG,GAAG;MAAE,CAAC,CAAC;MACtCE,YAAY,CAAC,QAAQ,CAAC;IAC1B;IACA,IAAIuB,CAAC,CAACC,GAAG,KAAK,WAAW,IAAI3B,GAAG,GAAGY,UAAU,CAACqB,IAAI,GAAG,CAAC,EAAE;MACpDP,CAAC,CAACG,cAAc,CAAC,CAAC;MAClB9B,eAAe,CAAC;QAAEC,GAAG,EAAEA,GAAG,GAAG,CAAC;QAAEC;MAAI,CAAC,CAAC;MACtCE,YAAY,CAAC,MAAM,CAAC;IACxB;IACA,IAAIuB,CAAC,CAACC,GAAG,KAAK,SAAS,IAAI3B,GAAG,GAAG,CAAC,EAAE;MAChC0B,CAAC,CAACG,cAAc,CAAC,CAAC;MAClB9B,eAAe,CAAC;QAAEC,GAAG,EAAEA,GAAG,GAAG,CAAC;QAAEC;MAAI,CAAC,CAAC;MACtCE,YAAY,CAAC,MAAM,CAAC;IACxB;;IAEA;IACA,IAAIuB,CAAC,CAACC,GAAG,KAAK,GAAG,EAAE;MACfD,CAAC,CAACG,cAAc,CAAC,CAAC;MAClB1B,YAAY,CAACmB,IAAI,IAAIA,IAAI,KAAK,QAAQ,GAAG,MAAM,GAAG,QAAQ,CAAC;IAC/D;EACJ,CAAC,EAAE,CAACxB,YAAY,EAAEI,SAAS,EAAEU,UAAU,EAAEjB,YAAY,EAAEmB,kBAAkB,CAAC,CAAC;EAE3E3B,SAAS,CAAC,MAAM;IACZ+C,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEV,aAAa,CAAC;IACjD,OAAO,MAAMS,MAAM,CAACE,mBAAmB,CAAC,SAAS,EAAEX,aAAa,CAAC;EACrE,CAAC,EAAE,CAACA,aAAa,CAAC,CAAC;;EAEnB;EACA,MAAMY,eAAe,GAAGA,CAACrC,GAAG,EAAEC,GAAG,KAAK;IAClC,MAAM8B,WAAW,GAAGjB,kBAAkB,CAAChB,YAAY,CAACE,GAAG,EAAEF,YAAY,CAACG,GAAG,EAAEC,SAAS,CAAC;IACrF,IAAI,CAAC6B,WAAW,EAAE,OAAO,KAAK;IAE9B,IAAI7B,SAAS,KAAK,QAAQ,EAAE;MACxB,OAAOF,GAAG,KAAK+B,WAAW,CAAC/B,GAAG,IAAIC,GAAG,IAAI8B,WAAW,CAAC9B,GAAG,IAAIA,GAAG,GAAG8B,WAAW,CAAC9B,GAAG,GAAG8B,WAAW,CAACd,IAAI,CAACC,MAAM;IAC/G,CAAC,MAAM;MACH,OAAOjB,GAAG,KAAK8B,WAAW,CAAC9B,GAAG,IAAID,GAAG,IAAI+B,WAAW,CAAC/B,GAAG,IAAIA,GAAG,GAAG+B,WAAW,CAAC/B,GAAG,GAAG+B,WAAW,CAACd,IAAI,CAACC,MAAM;IAC/G;EACJ,CAAC;;EAED;EACA,MAAMoB,aAAa,GAAGA,CAACtC,GAAG,EAAEC,GAAG,KAAK;IAChC,MAAMgB,IAAI,GAAGJ,KAAK,CAACG,IAAI,CAACuB,CAAC,IAAIA,CAAC,CAACvC,GAAG,KAAKA,GAAG,IAAIuC,CAAC,CAACtC,GAAG,KAAKA,GAAG,CAAC;IAC5D,OAAOgB,IAAI,GAAGA,IAAI,CAACuB,MAAM,GAAG,IAAI;EACpC,CAAC;;EAED;EACA,MAAMpB,YAAY,GAAGA,CAACpB,GAAG,EAAEC,GAAG,KAAK;IAC/B,OAAOY,KAAK,CAACQ,IAAI,CAACJ,IAAI,IAAI;MACtB,IAAIA,IAAI,CAACf,SAAS,KAAK,QAAQ,EAAE;QAC7B,OAAOe,IAAI,CAACjB,GAAG,KAAKA,GAAG,IAAIC,GAAG,IAAIgB,IAAI,CAAChB,GAAG,IAAIA,GAAG,GAAGgB,IAAI,CAAChB,GAAG,GAAGgB,IAAI,CAACA,IAAI,CAACC,MAAM;MACnF,CAAC,MAAM;QACH,OAAOD,IAAI,CAAChB,GAAG,KAAKA,GAAG,IAAID,GAAG,IAAIiB,IAAI,CAACjB,GAAG,IAAIA,GAAG,GAAGiB,IAAI,CAACjB,GAAG,GAAGiB,IAAI,CAACA,IAAI,CAACC,MAAM;MACnF;IACJ,CAAC,CAAC;EACN,CAAC;EAED,oBACI3B,OAAA;IAAKkD,SAAS,EAAC,0BAA0B;IAAAlC,QAAA,gBACrChB,OAAA;MACIkD,SAAS,EAAC,gBAAgB;MAC1BC,GAAG,EAAEtC,OAAQ;MACbuC,KAAK,EAAE;QACHC,mBAAmB,EAAE,UAAUhC,UAAU,CAACoB,IAAI,QAAQ;QACtDa,gBAAgB,EAAE,UAAUjC,UAAU,CAACqB,IAAI;MAC/C,CAAE;MAAA1B,QAAA,EAEDF,IAAI,CAACyC,GAAG,CAAC,CAAC9C,GAAG,EAAE+C,QAAQ,KACpB/C,GAAG,CAAC8C,GAAG,CAAC,CAACE,IAAI,EAAEC,QAAQ,KAAK;QACxB,MAAMC,UAAU,GAAGZ,aAAa,CAACS,QAAQ,EAAEE,QAAQ,CAAC;QACpD,MAAME,UAAU,GAAGrD,YAAY,CAACE,GAAG,KAAK+C,QAAQ,IAAIjD,YAAY,CAACG,GAAG,KAAKgD,QAAQ;QACjF,MAAMG,aAAa,GAAGf,eAAe,CAACU,QAAQ,EAAEE,QAAQ,CAAC;QACzD,MAAMI,MAAM,GAAGjC,YAAY,CAAC2B,QAAQ,EAAEE,QAAQ,CAAC;QAE/C,oBACI1D,OAAA;UAEIkD,SAAS,EAAE,kBAAkBY,MAAM,GAAG,WAAW,GAAG,cAAc,IAAIF,UAAU,GAAG,UAAU,GAAG,EAAE,IAC1FC,aAAa,GAAG,aAAa,GAAG,EAAE,EAAG;UAC7CE,OAAO,EAAEA,CAAA,KAAMnC,eAAe,CAAC4B,QAAQ,EAAEE,QAAQ,CAAE;UAAA1C,QAAA,GAElD2C,UAAU,iBAAI3D,OAAA;YAAMkD,SAAS,EAAC,aAAa;YAAAlC,QAAA,EAAE2C;UAAU;YAAA1C,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAO,CAAC,EAC/D0C,MAAM,iBACH9D,OAAA;YACIgE,IAAI,EAAC,MAAM;YACXd,SAAS,EAAC,YAAY;YACtBe,KAAK,EAAER,IAAI,IAAI,EAAG;YAClBS,SAAS,EAAE,CAAE;YACbC,QAAQ;YACRC,QAAQ,EAAE,CAAC;UAAE;YAAAnD,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAChB,CACJ;QAAA,GAfI,GAAGoC,QAAQ,IAAIE,QAAQ,EAAE;UAAAzC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAgB7B,CAAC;MAEd,CAAC,CACL;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACA,CAAC,eACNpB,OAAA;MAAKkD,SAAS,EAAC,mBAAmB;MAAAlC,QAAA,eAC9BhB,OAAA;QAAAgB,QAAA,gBACIhB,OAAA;UAAAgB,QAAA,EAAQ;QAAS;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAQ,CAAC,sFAE9B;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAG;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACL,CAAC;AAEd;AAACd,EAAA,CAvMQL,aAAa;AAAAoE,EAAA,GAAbpE,aAAa;AAyMtB,eAAeA,aAAa;AAAC,IAAAoE,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}