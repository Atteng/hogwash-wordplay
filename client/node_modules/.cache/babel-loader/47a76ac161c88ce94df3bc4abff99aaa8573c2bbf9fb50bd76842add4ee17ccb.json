{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Awaji-Iyaham Atteng\\\\Desktop\\\\hogwash-wordplay\\\\client\\\\src\\\\components\\\\SplashScreen.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport './SplashScreen.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SplashScreen = ({\n  onComplete\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // Cleanup existing children if any (React StrictMode safety)\n    canvas.innerHTML = '';\n    const pinkPalette = ['#D81B60', '#AD1457', '#880E4F', '#F06292', '#ec407a'];\n\n    // Calculate grid dimensions to cover screen roughly \n    // User snippet used 40 columns. \n    // To ensure full coverage, let's estimate rows based on viewport ratio if needed,\n    // but user used fixed 40*25. 40*25 might not cover a vertical phone or large monitor.\n    // Let's stick to their request \"40 * 25\" for the effect logic, \n    // but maybe increase count to safe-fill screen? \n    // A 1920x1080 screen with 40 cols means pixels are wide.\n    // Let's assume their 1000 pixels is what they want for the look.\n    const COLUMNS = 40;\n    const ROWS = 25;\n    const pixelCount = COLUMNS * ROWS;\n    const pixels = [];\n\n    // 1. Generate the pixels\n    for (let i = 0; i < pixelCount; i++) {\n      const pixel = document.createElement('div');\n      pixel.classList.add('pixel');\n      canvas.appendChild(pixel);\n      pixels.push(pixel);\n    }\n\n    // 2. Initial \"Colorful Initialization\" (Random Fade In)\n    pixels.forEach(pixel => {\n      setTimeout(() => {\n        pixel.style.backgroundColor = pinkPalette[Math.floor(Math.random() * pinkPalette.length)];\n        pixel.classList.add('pop');\n      }, Math.random() * 2000); // Spread fade-in over 2 seconds\n    });\n\n    // 3. The \"White Pixel\" transition (Starts after 3 seconds)\n    // User said 3500ms\n    const whiteOutStart = 3500;\n    const whiteOutTimeout = setTimeout(() => {\n      pixels.forEach((pixel, index) => {\n        // Creates a diagonal \"wave\" effect like the video\n        const row = Math.floor(index / COLUMNS);\n        const col = index % COLUMNS;\n        setTimeout(() => {\n          pixel.classList.add('white-out');\n        }, (row + col) * 40);\n      });\n    }, whiteOutStart);\n\n    // 4. Calculate End Time to transition\n    // Max delay = (24 + 39) * 40 = 63 * 40 = 2520ms\n    // Total = 3500 + 2520 + 800 (transition) = ~6820ms\n    // Let's give it a rounded 7500ms to be safe and let user see the white screen for a moment\n    const completionTimeout = setTimeout(() => {\n      if (onComplete) onComplete();\n    }, whiteOutStart + 2600 + 1000);\n\n    // Cleanup\n    return () => {\n      clearTimeout(whiteOutTimeout);\n      clearTimeout(completionTimeout);\n      if (canvas) canvas.innerHTML = '';\n    };\n  }, [onComplete]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"splash-screen-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"pixel-canvas\",\n      ref: canvasRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 79,\n    columnNumber: 9\n  }, this);\n};\n_s(SplashScreen, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashScreen;\nexport default SplashScreen;\nvar _c;\n$RefreshReg$(_c, \"SplashScreen\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","SplashScreen","onComplete","_s","canvasRef","canvas","current","innerHTML","pinkPalette","COLUMNS","ROWS","pixelCount","pixels","i","pixel","document","createElement","classList","add","appendChild","push","forEach","setTimeout","style","backgroundColor","Math","floor","random","length","whiteOutStart","whiteOutTimeout","index","row","col","completionTimeout","clearTimeout","className","children","id","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Awaji-Iyaham Atteng/Desktop/hogwash-wordplay/client/src/components/SplashScreen.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport './SplashScreen.css';\r\n\r\nconst SplashScreen = ({ onComplete }) => {\r\n    const canvasRef = useRef(null);\r\n\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        // Cleanup existing children if any (React StrictMode safety)\r\n        canvas.innerHTML = '';\r\n\r\n        const pinkPalette = ['#D81B60', '#AD1457', '#880E4F', '#F06292', '#ec407a'];\r\n\r\n        // Calculate grid dimensions to cover screen roughly \r\n        // User snippet used 40 columns. \r\n        // To ensure full coverage, let's estimate rows based on viewport ratio if needed,\r\n        // but user used fixed 40*25. 40*25 might not cover a vertical phone or large monitor.\r\n        // Let's stick to their request \"40 * 25\" for the effect logic, \r\n        // but maybe increase count to safe-fill screen? \r\n        // A 1920x1080 screen with 40 cols means pixels are wide.\r\n        // Let's assume their 1000 pixels is what they want for the look.\r\n        const COLUMNS = 40;\r\n        const ROWS = 25;\r\n        const pixelCount = COLUMNS * ROWS;\r\n\r\n        const pixels = [];\r\n\r\n        // 1. Generate the pixels\r\n        for (let i = 0; i < pixelCount; i++) {\r\n            const pixel = document.createElement('div');\r\n            pixel.classList.add('pixel');\r\n            canvas.appendChild(pixel);\r\n            pixels.push(pixel);\r\n        }\r\n\r\n        // 2. Initial \"Colorful Initialization\" (Random Fade In)\r\n        pixels.forEach((pixel) => {\r\n            setTimeout(() => {\r\n                pixel.style.backgroundColor = pinkPalette[Math.floor(Math.random() * pinkPalette.length)];\r\n                pixel.classList.add('pop');\r\n            }, Math.random() * 2000); // Spread fade-in over 2 seconds\r\n        });\r\n\r\n        // 3. The \"White Pixel\" transition (Starts after 3 seconds)\r\n        // User said 3500ms\r\n        const whiteOutStart = 3500;\r\n\r\n        const whiteOutTimeout = setTimeout(() => {\r\n            pixels.forEach((pixel, index) => {\r\n                // Creates a diagonal \"wave\" effect like the video\r\n                const row = Math.floor(index / COLUMNS);\r\n                const col = index % COLUMNS;\r\n\r\n                setTimeout(() => {\r\n                    pixel.classList.add('white-out');\r\n                }, (row + col) * 40);\r\n            });\r\n        }, whiteOutStart);\r\n\r\n        // 4. Calculate End Time to transition\r\n        // Max delay = (24 + 39) * 40 = 63 * 40 = 2520ms\r\n        // Total = 3500 + 2520 + 800 (transition) = ~6820ms\r\n        // Let's give it a rounded 7500ms to be safe and let user see the white screen for a moment\r\n        const completionTimeout = setTimeout(() => {\r\n            if (onComplete) onComplete();\r\n        }, whiteOutStart + 2600 + 1000);\r\n\r\n        // Cleanup\r\n        return () => {\r\n            clearTimeout(whiteOutTimeout);\r\n            clearTimeout(completionTimeout);\r\n            if (canvas) canvas.innerHTML = '';\r\n        };\r\n    }, [onComplete]);\r\n\r\n    return (\r\n        <div className=\"splash-screen-container\">\r\n            <div id=\"pixel-canvas\" ref={canvasRef}></div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default SplashScreen;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}